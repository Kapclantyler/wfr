warn("ConfigManager v2.5 - Fixed")
local ConfigManager = {}
ConfigManager.__index = ConfigManager
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local SYSTEM_VERSION = "2.2"
local CONFIG_FOLDER = "LynixHub_Configs"
local DEFAULT_CONFIG = "Default"

local function getFileSystemType()
    local fs = {
        hasListFiles = typeof(listfiles) == "function",
        hasIsFolder = typeof(isfolder) == "function",
        hasMakeFolder = typeof(makefolder) == "function",
        hasIsFile = typeof(isfile) == "function",
        hasWriteFile = typeof(writefile) == "function",
        hasReadFile = typeof(readfile) == "function",
        hasDelFile = typeof(delfile) == "function"
    }
    fs.hasBasicFS = fs.hasIsFile and fs.hasWriteFile and fs.hasReadFile
    fs.hasFullFS = fs.hasBasicFS and fs.hasMakeFolder and fs.hasIsFolder
    return fs
end

local fileSystem = getFileSystemType()

local function safeCreateDirectory(path)
    if not fileSystem.hasFullFS then return false end
    local success = pcall(function()
        if not isfolder(path) then
            makefolder(path)
        end
    end)
    return success and isfolder(path)
end

local function safeWriteFile(path, content)
    if not fileSystem.hasWriteFile then return false end
    local success = pcall(function()
        writefile(path, content)
    end)
    return success
end

local function safeReadFile(path)
    if not fileSystem.hasReadFile or not fileSystem.hasIsFile then return nil end
    local success, content = pcall(function()
        if isfile(path) then
            return readfile(path)
        end
        return nil
    end)
    return success and content or nil
end

local function safeDeleteFile(path)
    if not fileSystem.hasIsFile then return false end
    local success = pcall(function()
        if isfile(path) then
            if fileSystem.hasDelFile then
                delfile(path)
            else
                writefile(path, "")
            end
        end
    end)
    return success
end

local function safeListFiles(directory)
    if not fileSystem.hasListFiles or not fileSystem.hasIsFolder then return {} end
    local success, files = pcall(function()
        if isfolder(directory) then
            return listfiles(directory) or {}
        end
        return {}
    end)
    return success and files or {}
end

function ConfigManager.new(hubInstance)
    local self = setmetatable({}, ConfigManager)
    self.hubInstance = hubInstance
    self.configFolder = CONFIG_FOLDER
    self.currentConfig = DEFAULT_CONFIG
    self.httpService = HttpService
    self.isInitialized = false
    self.hasFileSystem = fileSystem.hasBasicFS
    self.memoryStore = {configs = {}}
    self:delayedInitialize()
    return self
end

function ConfigManager:delayedInitialize()
    task.spawn(function()
        local attempts = 0
        local maxAttempts = 20
        while attempts < maxAttempts do
            attempts = attempts + 1
            if self.hubInstance and self.hubInstance.tabs and #self.hubInstance.tabs > 0 then
                task.wait(0.3)
                local success = self:initializeConfigSystem()
                if success then
                    self.isInitialized = true
                    self:cleanupDuplicateConfigs()
                    task.wait(0.2)
                    if not self:configExists(DEFAULT_CONFIG) then
                        self:createDefaultConfig()
                    end
                    self:safeNotify('success', 'Config System', 'Ready! (FS: ' .. (self.hasFileSystem and 'Yes' or 'Memory') .. ')', 3)
                    break
                end
            end
            task.wait(0.15)
        end
        if not self.isInitialized then
            self:safeNotify('error', 'Config System', 'Failed to initialize')
            self.hasFileSystem = false
            self.isInitialized = true
            self:ensureDefaultConfig()
        end
    end)
end

function ConfigManager:initializeConfigSystem()
    local success = pcall(function()
        if self.hasFileSystem then
            self:setupFileSystem()
            local testSuccess = self:testFileSystemPersistence()
            if not testSuccess then
                warn("[ConfigManager] Filesystem test failed, retrying...")
                self:repairFileSystem()
            end
        else
            self:safeNotify('warning', 'File System', 'Using memory storage only', 4)
            task.spawn(function()
                task.wait(2)
                self:repairFileSystem()
            end)
        end
        self:ensureDefaultConfig()
        return true
    end)
    return success
end

function ConfigManager:setupFileSystem()
    if not fileSystem.hasFullFS then return end
    local paths = {
        "workspace/" .. self.configFolder,
        self.configFolder,
        "autoexec/" .. self.configFolder,
    }
    for _, path in ipairs(paths) do
        if safeCreateDirectory(path) then
            local testFile = path .. "/test.tmp"
            local testContent = "test_" .. os.time()
            if safeWriteFile(testFile, testContent) then
                task.wait(0.1)
                local readBack = safeReadFile(testFile)
                if readBack == testContent then
                    self.configFolder = path
                    safeDeleteFile(testFile)
                    print("[ConfigManager] Using folder:", path)
                    return
                end
            end
        end
    end
    self.hasFileSystem = false
    warn("[ConfigManager] No valid filesystem path found")
end

function ConfigManager:ensureDefaultConfig()
    for attempt = 1, 5 do
        if self:configExists(DEFAULT_CONFIG) then
            return true
        end
        local defaultData = self:createDefaultConfigData()
        local success = self:saveConfigData(DEFAULT_CONFIG, defaultData)
        if success then
            task.wait(0.2)
            if self:configExists(DEFAULT_CONFIG) then
                return true
            end
        end
        if attempt < 5 then
            task.wait(0.3)
        end
    end
    local defaultData = self:createDefaultConfigData()
    self.memoryStore.configs[DEFAULT_CONFIG] = defaultData
    return true
end

function ConfigManager:createDefaultConfig()
    local defaultData = self:createDefaultConfigData()
    return self:saveConfigData(DEFAULT_CONFIG, defaultData)
end

function ConfigManager:createDefaultConfigData()
    return {
        name = DEFAULT_CONFIG,
        settings = {
            metadata = {
                version = SYSTEM_VERSION,
                timestamp = os.time(),
                playerName = Players.LocalPlayer.Name
            },
            globalSettings = {
                menuToggleKey = "RightShift",
                watermarkVisible = true,
                themeColor = {r = 110, g = 117, b = 243}
            },
            elements = {},
            tabs = {}
        },
        metadata = {
            version = SYSTEM_VERSION,
            created = os.time(),
            lastModified = os.time(),
            creator = Players.LocalPlayer.Name,
            description = "Default configuration",
            creatorId = game.CreatorId
        }
    }
end

function ConfigManager:gatherAllSettings()
    if not self.hubInstance then
        return self:createDefaultConfigData().settings
    end
    
    local settings = {
        metadata = {
            version = SYSTEM_VERSION,
            timestamp = os.time(),
            playerName = Players.LocalPlayer.Name
        },
        globalSettings = {
            menuToggleKey = "RightShift",
            watermarkVisible = true,
            themeColor = {r = 110, g = 117, b = 243}
        },
        elements = {},
        tabs = {}
    }
    
    pcall(function()
        if self.hubInstance._toggleKeyCode then
            settings.globalSettings.menuToggleKey = self.hubInstance._toggleKeyCode.Name
        end
        if self.hubInstance._watermarkVisible ~= nil then
            settings.globalSettings.watermarkVisible = self.hubInstance._watermarkVisible
        end
        if self.hubInstance.options and self.hubInstance.options.theme and self.hubInstance.options.theme.primary then
            settings.globalSettings.themeColor = self:colorToRGB(self.hubInstance.options.theme.primary)
        end
    end)
    
    pcall(function()
        if self.hubInstance.tabs then
            for i, tab in ipairs(self.hubInstance.tabs) do
                if tab and tab.frame then
                    local tabName = tab.frame.Name:gsub("Content", "")
                    if tabName ~= "Settings" then
                        settings.tabs[tabName] = {
                            index = i,
                            hasContent = true
                        }
                    end
                end
            end
        end
    end)
    
    self:gatherRegisteredElements(settings)
    
    return settings
end

function ConfigManager:gatherRegisteredElements(settings)
    local excludeElements = {"Auto Load Config"}
    local excludeTypes = {"button", "keybind"}
    
    if not self.hubInstance or not self.hubInstance._getAllRegisteredElements then
        return
    end
    
    local elements = self.hubInstance:_getAllRegisteredElements()
    if not elements then return end
    
    if not settings.elements then
        settings.elements = {}
    end
    
    for elementId, element in pairs(elements) do
        local skip = false
        
        for _, excludeName in ipairs(excludeElements) do
            if element.elementName == excludeName then
                skip = true
                break
            end
        end
        
        if not skip then
            for _, excludeType in ipairs(excludeTypes) do
                if element.type == excludeType then
                    skip = true
                    break
                end
            end
        end
        
        if not skip and element.api and element.api.GetValue then
            local success, value = pcall(function()
                return element.api.GetValue()
            end)
            
            if success then
                local savedValue = value
                if element.type == "colorpicker" and typeof(value) == "Color3" then
                    savedValue = self:colorToRGB(value)
                elseif element.type == "multidropdown" and type(value) == "table" then
                    local selected = {}
                    for key, isSelected in pairs(value) do
                        if isSelected then
                            table.insert(selected, key)
                        end
                    end
                    savedValue = selected
                end
                
                -- Create stable key using tab, window, and element name
                local stableKey = string.format("%s|%s|%s", 
                    element.tabName or "unknown",
                    element.windowName or "unknown", 
                    element.elementName or "unknown"
                )
                
                settings.elements[stableKey] = {
                    type = element.type,
                    tabName = element.tabName,
                    windowName = element.windowName,
                    elementName = element.elementName,
                    value = savedValue,
                    path = element.path
                }
            end
        end
    end
end

function ConfigManager:applySettings(settings, executeCallbacks)
    if not settings or not self.hubInstance then
        self:safeNotify('error', 'Apply Settings', 'Invalid settings data')
        return false
    end
    if executeCallbacks == nil then executeCallbacks = true end
    local success = pcall(function()
        if settings.globalSettings then
            if settings.globalSettings.menuToggleKey then
                self.hubInstance:SetToggleKey(settings.globalSettings.menuToggleKey)
            end
            if settings.globalSettings.watermarkVisible ~= nil then
                self.hubInstance:SetWatermarkVisible(settings.globalSettings.watermarkVisible)
            end
            if settings.globalSettings.themeColor then
                local color = self:rgbToColor(settings.globalSettings.themeColor)
                self.hubInstance:SetTheme({primary = color})
            end
        end
        if settings.elements then
            self:applyElementSettings(settings.elements, executeCallbacks)
        end
        return true
    end)
    if not success then
        self:safeNotify('error', 'Apply Settings', 'Failed to apply configuration')
    end
    return success
end

function ConfigManager:applyElementSettings(elements, executeCallbacks)
    local excludeElements = {"Auto Load Config"}
    
    if not self.hubInstance._getAllRegisteredElements then
        warn("[ConfigManager] No _getAllRegisteredElements function found")
        return
    end
    
    if executeCallbacks == nil then executeCallbacks = true end
    
    local registeredElements = self.hubInstance:_getAllRegisteredElements()
    
    -- Create lookup table by stable key
    local elementsByKey = {}
    for elementId, element in pairs(registeredElements) do
        local stableKey = string.format("%s|%s|%s", 
            element.tabName or "unknown",
            element.windowName or "unknown", 
            element.elementName or "unknown"
        )
        elementsByKey[stableKey] = element
    end
    
    local appliedCount = 0
    local callbacksExecuted = 0
    local skippedCount = 0
    
    print("[ConfigManager] Starting apply with", #elements, "saved elements")
    
    for stableKey, savedElement in pairs(elements) do
        if not savedElement or not savedElement.type then
            skippedCount = skippedCount + 1
            continue
        end
        
        local savedType = string.lower(tostring(savedElement.type))
        
        -- Skip keybinds
        if savedType == "keybind" or savedType:find("keybind") or savedType:find("key") then
            skippedCount = skippedCount + 1
            continue
        end
        
        if savedElement.elementName and (string.lower(savedElement.elementName):find("keybind") or string.lower(savedElement.elementName):find("key bind")) then
            skippedCount = skippedCount + 1
            continue
        end
        
        -- Check excluded names
        local skip = false
        for _, excludeName in ipairs(excludeElements) do
            if savedElement.elementName == excludeName then
                skip = true
                skippedCount = skippedCount + 1
                break
            end
        end
        
        if skip then continue end
        
        -- Find element by stable key
        local registeredElement = elementsByKey[stableKey]
        
        if not registeredElement then
            print("[ConfigManager] No match for:", savedElement.elementName)
            skippedCount = skippedCount + 1
            continue
        end
        
        if not registeredElement.api or not registeredElement.api.SetValue then
            print("[ConfigManager] No API/SetValue for:", savedElement.elementName)
            skippedCount = skippedCount + 1
            continue
        end
        
        if savedElement.value == nil then
            skippedCount = skippedCount + 1
            continue
        end
        
        -- Apply the value
        local success = pcall(function()
            local value = savedElement.value
            
            -- Type conversion
            if savedElement.type == "colorpicker" then
                if type(value) == "table" and value.r and value.g and value.b then
                    value = self:rgbToColor(value)
                elseif typeof(value) ~= "Color3" then
                    return
                end
            elseif savedElement.type == "checkbox" or savedElement.type == "toggle" then
                if type(value) ~= "boolean" then
                    return
                end
            elseif savedElement.type == "slider" then
                if type(value) ~= "number" then
                    return
                end
            elseif savedElement.type == "multidropdown" then
                if type(value) == "table" then
                    local selectedMap = {}
                    for _, key in ipairs(value) do
                        selectedMap[key] = true
                    end
                    value = selectedMap
                else
                    return
                end
            elseif savedElement.type == "dropdown" then
                if type(value) ~= "string" then
                    return
                end
            end
            
            -- Store callback
            local tempCallback = registeredElement.originalCallback
            
            -- Disable callback temporarily
            if registeredElement.originalCallback and type(registeredElement.originalCallback) == "function" then
                registeredElement.originalCallback = function() end
            end
            
            -- Apply value
            local setSuccess, setError = pcall(function()
                registeredElement.api.SetValue(value)
            end)
            
            if not setSuccess then
                print("[ConfigManager] SetValue failed for", savedElement.elementName, ":", setError)
                if tempCallback then
                    registeredElement.originalCallback = tempCallback
                end
                return
            end
            
            print("[ConfigManager] âœ“ Applied:", savedElement.elementName, "=", tostring(value))
            appliedCount = appliedCount + 1
            
            -- Restore callback
            if tempCallback then
                registeredElement.originalCallback = tempCallback
            end
            
            -- Execute callback if needed
            if executeCallbacks and tempCallback and type(tempCallback) == "function" then
                local shouldExecute = false
                
                if savedElement.type == "checkbox" or savedElement.type == "toggle" then
                    shouldExecute = (type(value) == "boolean" and value == true)
                elseif savedElement.type == "colorpicker" then
                    shouldExecute = (typeof(value) == "Color3")
                elseif savedElement.type == "slider" then
                    shouldExecute = (type(value) == "number")
                elseif savedElement.type == "dropdown" then
                    shouldExecute = (type(value) == "string")
                elseif savedElement.type == "multidropdown" then
                    shouldExecute = (type(value) == "table")
                end
                
                if shouldExecute then
                    pcall(function()
                        if savedElement.type == "colorpicker" then
                            tempCallback(value, 1)
                        else
                            tempCallback(value)
                        end
                        callbacksExecuted = callbacksExecuted + 1
                    end)
                end
            end
        end)
        
        if not success then
            skippedCount = skippedCount + 1
        end
    end
    
    print("[ConfigManager] ==================")
    print("[ConfigManager] Applied:", appliedCount, "| Callbacks:", callbacksExecuted, "| Skipped:", skippedCount)
    print("[ConfigManager] ==================")
end

function ConfigManager:saveConfig(configName)
    if not configName or configName == "" then
        self:safeNotify('error', 'Save Failed', 'Config name cannot be empty!')
        return false
    end
    
    local settings = self:gatherAllSettings()
    
    local configData = {
        name = configName,
        settings = settings,
        metadata = {
            version = SYSTEM_VERSION,
            created = os.time(),
            lastModified = os.time(),
            creator = Players.LocalPlayer.Name,
            description = "Configuration: " .. configName,
            creatorId = game.CreatorId
        }
    }
    
    local success = self:saveConfigData(configName, configData)
    
    if success then
        self.currentConfig = configName
        self:safeNotify('success', 'Config Saved', 'Configuration "' .. configName .. '" saved successfully!', 3)
        return true
    else
        self:safeNotify('error', 'Save Failed', 'Could not save configuration!')
        return false
    end
end

function ConfigManager:loadConfig(configName, executeCallbacks)
    if not configName or configName == "" then
        self:safeNotify('error', 'Load Failed', 'Config name cannot be empty!')
        return false
    end
    if executeCallbacks == nil then executeCallbacks = true end
    local configData = self:loadConfigData(configName)
    if not configData then
        self:safeNotify('error', 'Load Failed', 'Configuration "' .. configName .. '" not found!')
        return false
    end
    if configData.metadata and configData.metadata.creatorId then
        if configData.metadata.creatorId ~= game.CreatorId then
            self:safeNotify('error', 'Load Failed', 'Config is for a different game!', 4)
            return false
        end
    end
    local success = self:applySettings(configData.settings, executeCallbacks)
    if success then
        self.currentConfig = configName
        local callbackMsg = executeCallbacks and " (with callbacks)" or " (values only)"
        self:safeNotify('success', 'Config Loaded', 'Configuration "' .. configName .. '" loaded!' .. callbackMsg, 3)
        return true
    else
        self:safeNotify('error', 'Load Failed', 'Could not apply configuration!')
        return false
    end
end

function ConfigManager:createConfig(configName)
    if not configName or configName == "" then
        self:safeNotify('error', 'Create Failed', 'Config name cannot be empty!')
        return false
    end
    
    local waitAttempts = 0
    while not self.isInitialized and waitAttempts < 10 do
        waitAttempts = waitAttempts + 1
        task.wait(0.1)
    end
    
    if not self.isInitialized then
        self:ensureDefaultConfig()
        self.isInitialized = true
    end
    
    if self:configExists(configName) then
        self:safeNotify('warning', 'Config Exists', 'Configuration "' .. configName .. '" already exists!')
        return false
    end
    
    local success = self:saveConfig(configName)
    
    if success then
        local configData = self:loadConfigData(configName)
        if configData then
            self.memoryStore.configs[configName] = configData
            
            if self.hasFileSystem then
                local filePath = self.configFolder .. "/" .. configName .. ".json"
                local jsonString = self.httpService:JSONEncode(configData)
                safeWriteFile(filePath, jsonString)
                
                task.wait(0.2)
                local verifyContent = safeReadFile(filePath)
                if not verifyContent or verifyContent == "" then
                    warn("[ConfigManager] File write verification failed")
                end
            end
        end
        
        self:safeNotify('success', 'Config Created', 'Configuration "' .. configName .. '" created!', 3)
        return true
    else
        return false
    end
end

function ConfigManager:deleteConfig(configName)
    if not configName or configName == "" or string.lower(configName) == string.lower(DEFAULT_CONFIG) then
        self:safeNotify('error', 'Delete Failed', 'Cannot delete default configuration!')
        return false
    end
    local success = false
    if self.hasFileSystem then
        local filePath = self.configFolder .. "/" .. configName .. ".json"
        success = safeDeleteFile(filePath)
    end
    if self.memoryStore.configs[configName] then
        self.memoryStore.configs[configName] = nil
        success = true
    end
    if success then
        self:safeNotify('success', 'Config Deleted', 'Configuration "' .. configName .. '" deleted!', 3)
        return true
    else
        self:safeNotify('error', 'Delete Failed', 'Could not delete configuration!')
        return false
    end
end

function ConfigManager:saveConfigData(configName, configData)
    -- Save to memory FIRST
    self.memoryStore.configs[configName] = configData
    
    if self.hasFileSystem then
        local filePath = self.configFolder .. "/" .. configName .. ".json"
        local success, jsonString = pcall(function()
            return self.httpService:JSONEncode(configData)
        end)
        if success and jsonString then
            safeWriteFile(filePath, jsonString)
            -- Don't fail if file write doesn't work, we have it in memory
        end
    end
    
    return true  -- Always return true since we saved to memory
end

function ConfigManager:loadConfigData(configName)
    if not configName or configName == "" then return nil end
    
    -- Check memory first
    local memoryConfig = self.memoryStore.configs[configName]
    if memoryConfig then
        return memoryConfig
    end
    
    -- Check case-insensitive in memory
    for memConfigName, configData in pairs(self.memoryStore.configs) do
        if string.lower(memConfigName) == string.lower(configName) then
            return configData
        end
    end
    
    -- Try file system
    if self.hasFileSystem then
        local filePath = self.configFolder .. "/" .. configName .. ".json"
        local fileContent = safeReadFile(filePath)
        if fileContent then
            local success, result = pcall(function()
                return self.httpService:JSONDecode(fileContent)
            end)
            if success and result then
                -- Cache it in memory
                self.memoryStore.configs[configName] = result
                return result
            end
        end
    end
    
    return nil
end

function ConfigManager:configExists(configName)
    if not configName or configName == "" then return false end
    if self.hasFileSystem then
        local filePath = self.configFolder .. "/" .. configName .. ".json"
        if fileSystem.hasIsFile and isfile(filePath) then
            return true
        end
    end
    if self.memoryStore.configs[configName] then
        return true
    end
    for memConfigName, _ in pairs(self.memoryStore.configs) do
        if string.lower(memConfigName) == string.lower(configName) then
            return true
        end
    end
    return false
end

function ConfigManager:getConfigList()
    local configs = {}
    local configSet = {}
    
    if not self:configExists(DEFAULT_CONFIG) then
        self:ensureDefaultConfig()
    end
    
    if self.hasFileSystem then
        local files = safeListFiles(self.configFolder)
        for _, filePath in ipairs(files) do
            local fileName = filePath:match("[/\\]([^/\\]+)%.json$")
            if fileName and not configSet[string.lower(fileName)] then
                local content = safeReadFile(filePath)
                if content and content ~= "" then
                    local success, data = pcall(function()
                        return self.httpService:JSONDecode(content)
                    end)
                    
                    if success and data then
                        table.insert(configs, fileName)
                        configSet[string.lower(fileName)] = true
                    end
                end
            end
        end
    end
    
    for configName, _ in pairs(self.memoryStore.configs) do
        if not configSet[string.lower(configName)] then
            table.insert(configs, configName)
            configSet[string.lower(configName)] = true
        end
    end
    
    if not configSet[string.lower(DEFAULT_CONFIG)] then
        table.insert(configs, 1, DEFAULT_CONFIG)
    else
        for i, name in ipairs(configs) do
            if string.lower(name) == string.lower(DEFAULT_CONFIG) then
                table.remove(configs, i)
                table.insert(configs, 1, DEFAULT_CONFIG)
                break
            end
        end
    end
    
    local validConfigs = {}
    local currentCreatorId = game.CreatorId
    
    for _, configName in ipairs(configs) do
        if configName and configName ~= "" and self:configExists(configName) then
            local configData = self:loadConfigData(configName)
            if configData then
                if configData.metadata and configData.metadata.creatorId then
                    if configData.metadata.creatorId == currentCreatorId then
                        table.insert(validConfigs, configName)
                    end
                else
                    table.insert(validConfigs, configName)
                end
            end
        end
    end
    
    table.sort(validConfigs)
    
    return validConfigs
end

function ConfigManager:testFileSystemPersistence()
    if not self.hasFileSystem then return false end
    
    local testFile = self.configFolder .. "/test.tmp"
    local testContent = "test_" .. os.time()
    
    if safeWriteFile(testFile, testContent) then
        task.wait(0.1)
        local readContent = safeReadFile(testFile)
        safeDeleteFile(testFile)
        
        if readContent == testContent then
            return true
        end
    end
    return false
end

function ConfigManager:repairFileSystem()
    fileSystem = getFileSystemType()
    self.hasFileSystem = fileSystem.hasBasicFS
    if self.hasFileSystem then
        self:setupFileSystem()
    end
    return self.hasFileSystem
end

function ConfigManager:colorToRGB(color)
    if typeof(color) ~= "Color3" then
        return {r = 110, g = 117, b = 243}
    end
    return {
        r = math.floor(color.R * 255 + 0.5),
        g = math.floor(color.G * 255 + 0.5),
        b = math.floor(color.B * 255 + 0.5)
    }
end

function ConfigManager:rgbToColor(rgb)
    if type(rgb) ~= "table" then
        return Color3.fromRGB(110, 117, 243)
    end
    if not rgb.r or not rgb.g or not rgb.b then
        return Color3.fromRGB(110, 117, 243)
    end
    local r = math.clamp(tonumber(rgb.r) or 110, 0, 255)
    local g = math.clamp(tonumber(rgb.g) or 117, 0, 255)
    local b = math.clamp(tonumber(rgb.b) or 243, 0, 255)
    return Color3.fromRGB(r, g, b)
end

function ConfigManager:safeNotify(notifType, title, message, duration)
    duration = duration or 3
    pcall(function()
        if self.hubInstance and self.hubInstance.notifications then
            local method = self.hubInstance.notifications[notifType]
            if method and type(method) == "function" then
                method(self.hubInstance.notifications, title, message, duration)
            end
        end
    end)
end

function ConfigManager:cleanupDuplicateConfigs()
    local seenConfigs = {}
    local configsToRemove = {}
    for configName, _ in pairs(self.memoryStore.configs) do
        local lowerName = string.lower(configName)
        if seenConfigs[lowerName] then
            if configName == DEFAULT_CONFIG then
                table.insert(configsToRemove, seenConfigs[lowerName])
            else
                table.insert(configsToRemove, configName)
            end
        else
            seenConfigs[lowerName] = configName
        end
    end
    for _, configName in ipairs(configsToRemove) do
        self.memoryStore.configs[configName] = nil
    end
end

return ConfigManager
